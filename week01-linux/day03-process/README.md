# Day 3 – Process & Job Control

Day 3에서는 리눅스에서 실행 중인 **프로세스를 어떻게 확인하고 제어하는지**를
서버 엔지니어 관점에서 학습했다.

단순히 명령어를 실행하는 것이 아니라,
“지금 서버에서 이 프로그램은 살아있는가?”
를 판단하는 기준을 만드는 데 집중했다.

---

## What I learned

### Process (PID / PPID)
- 모든 프로세스는 PID를 가지며, 부모 프로세스(PPID)에 의해 생성된다
- 리눅스의 프로세스는 트리 구조로 관리된다는 점을 직접 확인했다
- PID는 실행 상태를 판단하는 핵심 기준이라는 것을 이해했다

### Foreground vs Background
- 포그라운드 프로세스는 터미널을 점유한다
- 백그라운드 프로세스는 터미널과 분리되어 실행된다
- 서버 서비스는 반드시 백그라운드에서 실행되어야 한다는 점을 체감했다

### Process Status & Monitoring
- `ps`, `top`을 통해 실행 중인 프로세스를 확인했다
- PID 파일에 기록된 PID와 실제 실행 중인 프로세스가 일치하는지 검증했다
- “실행 중인지 여부”는 파일이 아니라 **OS 기준으로 판단해야 함**을 배웠다

### Signal & Termination
- `kill`(SIGTERM)은 정상 종료 요청이다
- `kill -9`(SIGKILL)은 즉시 강제 종료이며 정리 작업이 수행되지 않는다
- 강제 종료는 stale pidfile 같은 운영 문제를 남길 수 있다는 점을 이해했다

---

## Key Takeaways

- 프로세스 관리는 실행보다 **상태 판단**이 더 중요하다
- PID 파일은 상태를 보조하는 수단일 뿐, 진실은 아니다
- 서버 운영에서는 “어떻게 죽이느냐”가 매우 중요하다

---

## Questions
- `kill -0`은 어떤 원리로 프로세스 상태만 확인할 수 있을까?
- systemd는 이런 프로세스 관리 문제를 어떻게 해결할까?

---

## One-line Summary
프로세스는 단순한 실행 대상이 아니라, **관리해야 할 운영 단위**라는 것을 이해한 하루였다.

