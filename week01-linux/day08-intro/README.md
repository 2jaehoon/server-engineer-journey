# Day 08 – Docker 개념 이해

Day 8에서는 Docker를 사용하기에 앞서,
Docker가 무엇을 해결하려는 도구인지와
기존 서버 운영 방식과 어떤 차이가 있는지를
개념 중심으로 정리했다.

명령어를 바로 사용하는 것보다,
지금까지 학습한 리눅스 개념들과
Docker가 어떻게 연결되는지를 이해하는 것이 목표였다.

---

## Docker는 무엇인가

Docker는 가상 머신처럼 보이지만,
실제로는 가상 운영체제가 아니다.

Docker 컨테이너는
호스트의 리눅스 커널을 그대로 사용하면서,
프로세스를 격리된 환경에서 실행하는 방식이다.

즉, 컨테이너 안에서 실행되는 애플리케이션도
결국은 하나의 리눅스 프로세스다.

---

## 컨테이너는 격리된 프로세스다

컨테이너는 별도의 서버가 아니라,
네임스페이스(namespace)와 같은 리눅스 기능을 통해
프로세스를 격리해서 실행한 결과물이다.

따라서 컨테이너 내부에서도
PID, 포트, 표준 출력(stdout), 표준 에러(stderr)와 같은
리눅스 개념이 그대로 적용된다.

---

## 포트와 로그 관점에서 본 Docker

Docker 컨테이너의 네트워크와 로그는
지금까지 학습한 개념과 직접적으로 연결된다.

- 컨테이너 내부 애플리케이션은 특정 포트를 LISTEN 한다
- 호스트와 연결하기 위해 포트 매핑이 필요하다
- 애플리케이션의 로그는 stdout, stderr로 출력된다
- Docker는 이 출력을 수집하여 로그로 관리한다

이는 리다이렉션과 포트 개념이
Docker 환경에서도 그대로 사용된다는 의미다.

---

## systemd와 Docker의 역할 차이

systemd와 Docker는 서로 경쟁하는 도구가 아니다.

- systemd는 서버 전체의 서비스 생명주기를 관리한다
- Docker는 애플리케이션 실행 환경을 격리하여 관리한다

systemd는 운영체제 관점의 도구이고,
Docker는 애플리케이션 관점의 도구라고 이해할 수 있다.

---

## 느낀 점

- Docker는 새로운 개념처럼 보이지만,
  실제로는 리눅스 프로세스와 네트워크 개념의 연장선에 있다
- 지금까지 학습한 프로세스, 포트, 로그 개념이
  Docker를 이해하는 데 그대로 사용된다는 점이 인상적이었다

---

## 한 줄 정리

Docker는 가상 머신이 아니라,
리눅스 커널 위에서 실행되는
격리된 프로세스 실행 방식이다.
