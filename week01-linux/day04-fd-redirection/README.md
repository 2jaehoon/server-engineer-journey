# Day 4 – 파일 디스크립터와 리다이렉션

Day 4에서는 리눅스에서 프로그램의 출력이
어디로 흘러가는지를 이해하는 데 집중했다.

단순히 명령어를 실행하는 것이 아니라,
서버 환경에서 **로그가 왜 저 위치에 남는지**를
설명할 수 있는 것이 목표였다.

---

## 학습 내용

### 파일 디스크립터(File Descriptor)
- 리눅스 프로세스는 기본적으로 3개의 파일 디스크립터를 가진다
  - 0: 표준 입력(stdin)
  - 1: 표준 출력(stdout)
  - 2: 표준 에러(stderr)
- 터미널 또한 하나의 파일처럼 취급되며,
  출력은 파일 디스크립터를 통해 전달된다는 점을 이해했다

### stdout과 stderr의 분리
- 정상 출력과 에러 출력은 서로 다른 스트림으로 관리된다
- stdout만 리다이렉션하면 에러는 여전히 터미널에 출력된다
- 에러 로그를 분리하지 않으면 장애 분석이 어려워질 수 있다

### 리다이렉션 동작 방식
- `>`는 stdout을 파일로 덮어쓴다
- `>>`는 stdout을 파일에 이어서 쓴다
- `2>`는 stderr만 파일로 보낸다
- `2>&1`은 stderr를 stdout이 향하는 위치로 보낸다

### nohup과 출력 처리
- `nohup`은 터미널 종료와 관계없이 프로세스를 유지한다
- stdout과 stderr를 지정하지 않으면 `nohup.out` 파일이 생성된다
- `/dev/null`로 리다이렉션하면 모든 출력을 버리게 된다

---

## 느낀 점

- 로그는 단순한 출력이 아니라 운영을 위한 중요한 정보라는 것을 느꼈다
- stdout과 stderr를 명확히 구분하지 않으면
  문제가 발생했을 때 원인을 추적하기 어렵다
- 이전에 사용하던 `2>&1` 옵션을 이제는 의미를 이해하고 사용할 수 있게 되었다

---

## 한 줄 정리

프로그램을 실행하는 것보다,
**출력이 어디로 흘러가는지를 설계하는 것이 더 중요하다는 것을 배운 하루였다.**
